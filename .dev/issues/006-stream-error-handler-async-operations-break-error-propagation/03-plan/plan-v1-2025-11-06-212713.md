# Bug Fix Plan: Stream Error Handler Async Operations Break Error Propagation

**Issue:** #6
**Plan Date:** 2025-11-06T07:00:00Z
**Severity:** High
**Status:** phase:ready-for-fix

---

## Fix Summary

**Lines Changed:** 3
**Files Modified:** 1 (src/index.ts)
**Regression Tests:** 5 (3 unit + 2 integration)
**Manual Verification:** 4 steps
**Risk:** Low (minimal change, comprehensive testing)

---

## Fix Approach

**Principle:** Change ONLY what's necessary to fix the bug. No refactoring. No additions.

**Root Cause Recap:**
- **File:** `src/index.ts:184-199`
- **Bug:** `throw new McpError(...)` inside async event handler callback is lost
- **Expected:** Error should be captured and propagated through Promise rejection

**Minimal Fix:**

### File: `servers/binaries/youtube-mcp-server/src/index.ts`

**BEFORE (Lines 184-235):**
```typescript
// Line 184-199: Broken error handler with throw
writeStream.on('error', async (err: Error) => {
  console.error('Stream write error:', err);
  
  // Cleanup partial file
  try {
    await fs.unlink(absoluteOutputPath);
    console.error(`Cleaned up partial file: ${absoluteOutputPath}`);
  } catch (unlinkErr) {
    console.error('Failed to cleanup partial file:', unlinkErr);
  }
  
  throw new McpError(  // ❌ LOST - throw in event handler
    ErrorCode.InternalError,
    `Failed to write transcript: ${err.message}`
  );
});

// ... (lines 200-228: chunk processing - NO CHANGES) ...

// Line 229-235: Promise wrapper
await new Promise<void>((resolve, reject) => {
  writeStream.end(() => {
    console.error(`Transcript saved to: ${absoluteOutputPath}`);
    resolve();
  });
  writeStream.on('error', reject);  // Duplicate listener
});
```

**AFTER (Lines 184-235):**
```typescript
// Line 184: Add error capture variable
let streamError: Error | null = null;

// Line 185-199: Modified error handler - capture instead of throw
writeStream.on('error', async (err: Error) => {
  streamError = err;  // ✅ CAPTURE - store error for later
  console.error('Stream write error:', err);
  
  // Cleanup partial file
  try {
    await fs.unlink(absoluteOutputPath);
    console.error(`Cleaned up partial file: ${absoluteOutputPath}`);
  } catch (unlinkErr) {
    console.error('Failed to cleanup partial file:', unlinkErr);
  }
  
  // ✅ REMOVED - throw statement deleted
});

// ... (lines 200-228: chunk processing - NO CHANGES) ...

// Line 229-235: Modified Promise wrapper - check captured error
await new Promise<void>((resolve, reject) => {
  writeStream.end(() => {
    if (streamError) {  // ✅ CHECK - reject if error was captured
      reject(new McpError(
        ErrorCode.InternalError,
        `Failed to write transcript: ${streamError.message}`
      ));
    } else {
      console.error(`Transcript saved to: ${absoluteOutputPath}`);
      resolve();
    }
  });
  // ✅ REMOVED - duplicate error listener deleted
});
```

**Lines Changed:** 3
1. Line 184: Add `let streamError: Error | null = null;`
2. Line 186: Change to `streamError = err;` (remove throw, lines 195-198)
3. Line 230-236: Add `if (streamError) { reject(...) } else { ... }` (remove duplicate listener)

**Scope:** 
- Modify error handler to capture instead of throw
- Add error check before Promise resolve
- Remove duplicate error listener

**Why This Is Minimal:**
- Changes ONLY the error propagation logic (3 lines)
- No function signature changes
- No new dependencies
- No refactoring of chunk processing logic
- No "improvements while we're here"

**Alternative Approaches Rejected:**
- ❌ Refactor to use direct reject() only - loses cleanup capability (violates AC2)
- ❌ Add separate error handling middleware - over-engineering, more complexity
- ❌ Wrap entire stream in try-catch - doesn't work with event handlers
- ❌ Use Promise.race with timeout - doesn't address root cause

---

## Regression Test Strategy

**Coverage Target:** 100% of blast radius areas
**Test Types:** Unit, Integration, Manual Verification

---

### Regression Test Checklist

#### Unit Tests (New Tests to Add)

**Location:** `servers/binaries/youtube-mcp-server/tests/streaming.test.ts`

- [ ] **Test: Stream error captured and propagates to Promise rejection**
  - **File:** `tests/streaming.test.ts` (new test in existing describe block)
  - **Test Name:** `test_streamError_capturedAndRejected`
  - **Setup:** Create writeStream to invalid path `/invalid/path/test.md`
  - **Action:** Write data, wait for error event
  - **Expected:** Promise rejects with McpError containing original error message
  - **Why:** Core bug fix - ensures error capture pattern works

- [ ] **Test: Cleanup (fs.unlink) executes before Promise rejection**
  - **File:** `tests/streaming.test.ts` (new test)
  - **Test Name:** `test_streamError_cleanupBeforeRejection`
  - **Setup:** Create writeStream to valid path, write partial data, simulate error
  - **Action:** Mock fs.unlink to track call order
  - **Expected:** fs.unlink called BEFORE Promise rejects
  - **Why:** Validates AC2 - cleanup happens before error propagation

- [ ] **Test: Cleanup failure doesn't block error propagation**
  - **File:** `tests/streaming.test.ts` (new test)
  - **Test Name:** `test_streamError_cleanupFailureLogged`
  - **Setup:** Create writeStream, mock fs.unlink to throw error
  - **Action:** Trigger stream error, capture console.error logs
  - **Expected:** Promise still rejects with original error, cleanup failure logged
  - **Why:** Ensures robustness - cleanup errors don't mask main error

---

#### Integration Tests (Regression Coverage)

**From Blast Radius Analysis - 1 Affected Feature: get_transcript_and_save**

- [ ] **Integration Test: Error reaches outer catch block**
  - **File:** `tests/streaming.test.ts` (new test)
  - **Test Name:** `test_getTranscript_streamError_reachesOuterCatch`
  - **Scenario:** Simulate full tool invocation with stream error during write
  - **Setup:** Mock youtube-transcript to return valid data, use invalid output path
  - **Expected:** Outer catch block (lines 254-281) receives McpError, returns error response to client
  - **Why:** End-to-end verification - error propagates through full request handler

- [ ] **Integration Test: MCP client receives error response**
  - **File:** `tests/streaming.test.ts` (new test)
  - **Test Name:** `test_mcpClient_receivesErrorOnStreamFailure`
  - **Scenario:** Full MCP request/response cycle with stream error
  - **Setup:** Create MCP client, invoke get_transcript_and_save with invalid path
  - **Expected:** Response contains `isError: true` and error message
  - **Why:** Client-facing regression - ensures clients receive errors, not false success

---

#### Existing Tests (Regression Verification)

**All 12 existing tests in `tests/streaming.test.ts` MUST still pass:**

- [ ] **Chunk processing tests (lines 14-76)** - 3 tests
  - Verify chunk size logic unchanged
  - Verify decoding unchanged
  - Verify no side effects from error handling changes

- [ ] **HTML entity decoding (lines 78-96)** - 2 tests
  - Verify decoding logic unchanged

- [ ] **Memory usage tests (lines 98-132)** - 3 tests
  - Verify stream processing still memory-efficient
  - Verify peak memory <100MB unchanged

- [ ] **Progress logging (lines 134-171)** - 2 tests
  - Verify logging thresholds unchanged
  - Verify modulo arithmetic unchanged

- [ ] **Filename sanitization (lines 173-206)** - 2 tests
  - Verify sanitization logic unchanged

---

**Total Regression Tests:** 5 new + 12 existing = 17 tests
**Blast Radius Coverage:** 100% (only 1 feature exists, fully covered)

---

## Manual Verification Checklist

**After all automated tests pass, manually verify:**

### Verification Steps

- [ ] **Verify: Stream error with invalid path**
  - **Steps:**
    1. Start youtube-mcp-server locally
    2. Connect MCP client
    3. Call get_transcript_and_save with valid URL but invalid output path `/invalid/path/test.md`
    4. Observe response
  - **Expected:** MCP client receives error response with message "Failed to write transcript: ENOENT: no such file or directory"
  - **Actual:** ___________

- [ ] **Verify: Cleanup execution on error**
  - **Steps:**
    1. Create valid temp directory `/tmp/youtube-test/`
    2. Make directory read-only: `chmod 444 /tmp/youtube-test/`
    3. Call get_transcript_and_save with output path `/tmp/youtube-test/test.md`
    4. Check console logs for cleanup messages
  - **Expected:** Console shows "Cleaned up partial file" OR "Failed to cleanup partial file" before error
  - **Actual:** ___________

- [ ] **Verify: Success path unchanged**
  - **Steps:**
    1. Call get_transcript_and_save with valid URL and valid output path `/tmp/transcript.md`
    2. Verify file created successfully
    3. Check file contents
  - **Expected:** File created, contains full transcript, no error messages
  - **Actual:** ___________

- [ ] **Verify: Large transcript processing unchanged**
  - **Steps:**
    1. Find YouTube video >10,000 transcript entries
    2. Call get_transcript_and_save with valid path
    3. Monitor memory usage and progress logs
  - **Expected:** Progress logs appear, memory <100MB, transcript saved successfully
  - **Actual:** ___________

**All Checks Must Pass:** □ Yes  □ No

**If any fail:** Document in "Actual" column, mark fix for revision

---

## Rollback Plan

**Trigger Criteria for Rollback:**
- Any regression test fails after deployment
- Existing 12 tests fail (success path regression)
- Manual verification identifies unexpected behavior
- Error rate increases by >5% in production logs
- Stream errors still not reaching clients (fix failed)

**Rollback Procedure:**

### Immediate Rollback (< 5 minutes)
```bash
# Revert commit
git -C /Users/mekonen/.mcp-global revert <commit-hash> --no-edit

# Rebuild
npm --prefix /Users/mekonen/.mcp-global/servers/binaries/youtube-mcp-server run build

# Restart MCP server (if running)
# Claude Code will reload automatically on next request
```

### Post-Rollback Actions
1. **Notify stakeholders:** "Bug fix #6 reverted due to regression, investigating"
2. **Analyze failure:** Review test output, console logs, error messages
3. **Create new issue:** Document regression found, label `bug:regression`
4. **Revise plan:** Update fix approach to address regression, increment version to plan-v2

### Monitoring Metrics (Watch for 24h Post-Deploy)

| Metric | Baseline | Threshold | Action if Exceeded |
|--------|----------|-----------|-------------------|
| Stream error count (production) | Unknown (silent failures) | N/A | Monitor - expect INCREASE (good, errors now visible) |
| Success rate for get_transcript_and_save | ~95% | <90% | Investigate immediately |
| Test suite pass rate | 100% | <100% | Rollback immediately |
| Memory usage peak | <100MB | >150MB | Investigate performance regression |

**Rollback Decision Matrix:**

| Severity | Impact | Action | Timeline |
|----------|--------|--------|----------|
| Critical | Test suite fails | Immediate rollback | < 5 min |
| High | Manual verification fails | Rollback + hotfix | < 30 min |
| Medium | Success rate drops | Monitor + fix | < 24 hrs |
| Low | Minor log message changes | Fix in next release | Next sprint |

---

## Implementation Checklist

- [ ] Add `let streamError: Error | null = null;` at line 184 in `src/index.ts`
- [ ] Replace `throw new McpError(...)` with `streamError = err;` at line 186 (delete lines 195-198)
- [ ] Add `if (streamError) { reject(...) } else { ... }` at line 230-236 in Promise wrapper
- [ ] Remove duplicate error listener at line 234 (delete `writeStream.on('error', reject);`)
- [ ] Write 3 new unit tests in `tests/streaming.test.ts`
- [ ] Write 2 new integration tests in `tests/streaming.test.ts`
- [ ] Run FULL existing test suite → ALL PASS (12 tests, 0 new failures)
- [ ] Run NEW regression tests → ALL PASS (5 tests)
- [ ] Complete manual verification checklist → ALL 4 STEPS PASS
- [ ] **Run `/sop-regression-verification` → ALL 4 GATES PASS (MANDATORY)**
- [ ] Create PR with before/after behavior documentation
- [ ] Include rollback instructions in PR description
- [ ] Monitor logs for 24 hours post-merge

**DoD Criteria:**
- Fix implemented exactly as specified (3 lines changed, no deviations)
- All existing tests pass (12/12 - 0 new failures)
- All 5 new regression tests pass
- All 4 manual verification steps pass
- **ALL 4 regression gates PASS (unit, integration, manual, build) - MANDATORY**
- PR includes rollback instructions and monitoring plan
- Zero tolerance for test failures

**Regression Verification Process:**
After implementation complete, MUST execute:
```bash
/sop-regression-verification 6
```

This enforces:
- ✅ ALL unit tests PASS (existing 12 + new 3 = 15 tests)
- ✅ ALL integration tests PASS (new 2 tests)
- ✅ ALL manual verification PASS (4 steps)
- ✅ Build succeeds (npm run build)
- ✅ 100% blast radius coverage (1 feature verified)

**ANY regression gate failure = FIX BLOCKED until resolved**

---

## Test Implementation Details

### Unit Test 1: Stream Error Captured and Rejected

**File:** `tests/streaming.test.ts`
**Location:** Add to existing "Stream Error Handling" describe block (after line 221)

```typescript
it('should capture stream error and reject Promise with McpError', async () => {
  const invalidPath = '/invalid/path/that/does/not/exist/test.md';
  const writeStream = createWriteStream(invalidPath);
  
  let streamError: Error | null = null;
  
  writeStream.on('error', async (err: Error) => {
    streamError = err;
  });
  
  const writePromise = new Promise<void>((resolve, reject) => {
    writeStream.write('test content');
    writeStream.end(() => {
      if (streamError) {
        reject(new Error(`Failed to write: ${streamError.message}`));
      } else {
        resolve();
      }
    });
  });
  
  await expect(writePromise).rejects.toThrow('Failed to write');
});
```

### Unit Test 2: Cleanup Before Rejection

**File:** `tests/streaming.test.ts`

```typescript
it('should execute cleanup before rejecting Promise', async () => {
  const validPath = `${TEST_OUTPUT_DIR}/partial-file.md`;
  const writeStream = createWriteStream(validPath);
  
  const executionOrder: string[] = [];
  let streamError: Error | null = null;
  
  writeStream.on('error', async (err: Error) => {
    streamError = err;
    executionOrder.push('error-handler-start');
    
    // Simulate cleanup
    try {
      await fs.unlink(validPath);
      executionOrder.push('cleanup-success');
    } catch (unlinkErr) {
      executionOrder.push('cleanup-failed');
    }
    
    executionOrder.push('error-handler-end');
  });
  
  // Write valid content, then trigger error
  writeStream.write('test content');
  
  const writePromise = new Promise<void>((resolve, reject) => {
    writeStream.end(() => {
      if (streamError) {
        executionOrder.push('promise-reject');
        reject(streamError);
      } else {
        resolve();
      }
    });
  });
  
  // Force error by destroying stream
  writeStream.destroy(new Error('Simulated error'));
  
  await expect(writePromise).rejects.toThrow();
  
  // Verify order: cleanup happens BEFORE rejection
  const cleanupIndex = executionOrder.indexOf('cleanup-success');
  const rejectIndex = executionOrder.indexOf('promise-reject');
  expect(cleanupIndex).toBeLessThan(rejectIndex);
});
```

### Unit Test 3: Cleanup Failure Doesn't Block Error

**File:** `tests/streaming.test.ts`

```typescript
it('should propagate error even if cleanup fails', async () => {
  const nonExistentPath = `${TEST_OUTPUT_DIR}/does-not-exist.md`;
  const writeStream = createWriteStream(nonExistentPath);
  
  let streamError: Error | null = null;
  const consoleErrors: string[] = [];
  
  // Capture console.error calls
  const originalConsoleError = console.error;
  console.error = (...args: any[]) => {
    consoleErrors.push(args.join(' '));
    originalConsoleError(...args);
  };
  
  writeStream.on('error', async (err: Error) => {
    streamError = err;
    
    // Try cleanup (will fail - file doesn't exist)
    try {
      await fs.unlink(nonExistentPath);
    } catch (unlinkErr) {
      console.error('Failed to cleanup partial file:', unlinkErr);
    }
  });
  
  const writePromise = new Promise<void>((resolve, reject) => {
    writeStream.write('test');
    writeStream.end(() => {
      if (streamError) {
        reject(new Error(`Failed: ${streamError.message}`));
      } else {
        resolve();
      }
    });
  });
  
  await expect(writePromise).rejects.toThrow('Failed');
  
  // Verify cleanup failure was logged
  expect(consoleErrors.some(msg => msg.includes('Failed to cleanup'))).toBe(true);
  
  // Restore console.error
  console.error = originalConsoleError;
});
```

### Integration Test 1: Error Reaches Outer Catch

**File:** `tests/streaming.test.ts`

```typescript
it('should propagate stream error to outer catch block', async () => {
  // This test simulates the full tool handler flow
  // Requires mocking youtube-transcript to return valid data
  // Then using invalid output path to trigger stream error
  
  const invalidOutputPath = '/invalid/path/test.md';
  
  // Simulate tool handler structure
  const toolHandler = async () => {
    try {
      // Simulate transcript fetch (would be mocked)
      const transcriptEntries = [
        { text: 'Test entry 1' },
        { text: 'Test entry 2' }
      ];
      
      // Stream write (will fail with invalid path)
      const writeStream = createWriteStream(invalidOutputPath);
      let streamError: Error | null = null;
      
      writeStream.on('error', async (err: Error) => {
        streamError = err;
      });
      
      writeStream.write('# Test\n\n');
      for (const entry of transcriptEntries) {
        writeStream.write(entry.text + ' ');
      }
      
      await new Promise<void>((resolve, reject) => {
        writeStream.end(() => {
          if (streamError) {
            reject(new Error(`Failed to write transcript: ${streamError.message}`));
          } else {
            resolve();
          }
        });
      });
      
      return { success: true };
    } catch (error) {
      // Outer catch block - should receive the error
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  };
  
  const result = await toolHandler();
  
  expect(result.success).toBe(false);
  expect(result.error).toContain('Failed to write transcript');
});
```

### Integration Test 2: MCP Client Receives Error

**File:** `tests/streaming.test.ts`

```typescript
it('should return error response to MCP client on stream failure', async () => {
  // This test verifies the full MCP request/response cycle
  // Simulates what a real MCP client would receive
  
  const invalidOutputPath = '/invalid/path/test.md';
  
  // Simulate MCP tool request handler
  const handleToolRequest = async (request: { name: string; arguments: any }) => {
    try {
      // Simulate get_transcript_and_save implementation
      const writeStream = createWriteStream(invalidOutputPath);
      let streamError: Error | null = null;
      
      writeStream.on('error', async (err: Error) => {
        streamError = err;
      });
      
      writeStream.write('# Test Transcript\n\n');
      
      await new Promise<void>((resolve, reject) => {
        writeStream.end(() => {
          if (streamError) {
            reject(new Error(`Failed to write transcript: ${streamError.message}`));
          } else {
            resolve();
          }
        });
      });
      
      // Success response
      return {
        content: [{ type: 'text', text: 'Transcript saved successfully' }],
        isError: false
      };
    } catch (error) {
      // Error response (should reach here on stream failure)
      return {
        content: [{ 
          type: 'text', 
          text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}` 
        }],
        isError: true
      };
    }
  };
  
  const response = await handleToolRequest({
    name: 'get_transcript_and_save',
    arguments: { videoUrl: 'https://youtube.com/watch?v=test', outputPath: invalidOutputPath }
  });
  
  expect(response.isError).toBe(true);
  expect(response.content[0].text).toContain('Failed to write transcript');
});
```

---

## Files Modified Summary

**Total Files:** 1

### src/index.ts
- **Lines 184:** Add error capture variable
- **Lines 186-199:** Remove throw, use error capture
- **Lines 230-236:** Add error check before resolve, remove duplicate listener
- **Total Changes:** 3 modifications (add variable, modify handler, modify Promise)

### tests/streaming.test.ts
- **New Tests:** 5 (3 unit + 2 integration)
- **Location:** Add to existing "Stream Error Handling" describe block
- **Existing Tests:** 12 (must all still pass)

---

## Dependencies

**Existing (No Changes):**
- `fs/promises` - unlink for cleanup
- `createWriteStream` from 'fs' - file writing
- `McpError` - MCP error wrapping
- `ErrorCode` - Error code enum

**New:** None

**Removed:** None

---

## Risk Assessment

**Implementation Risk:** LOW
- Standard Node.js Promise + event handler pattern
- Well-documented in research (5 similar patterns found)
- Changes confined to 3 lines in single function

**Breaking Change Risk:** MEDIUM-HIGH
- Current behavior: Stream errors silently succeed
- New behavior: Stream errors properly reject
- Impact: ALL MCP clients will receive errors instead of false success
- Mitigation: This is INTENTIONAL bug fix - clients SHOULD handle errors

**Regression Risk:** LOW
- Only 1 feature in entire server (100% isolation)
- Success path logic unchanged (chunk processing untouched)
- Comprehensive regression tests (5 new + 12 existing)
- Manual verification includes success path

**Deployment Risk:** LOW
- No database changes
- No config changes
- No external dependencies
- Rollback is simple git revert

---

## Open Questions

- [ ] Should cleanup failures (fs.unlink errors) include details in McpError message or just log?
  - **Recommendation:** Just log (current plan) - cleanup failures shouldn't obscure main error
  - **Decision:** Keep current plan

- [ ] Should we add retry logic for transient errors (disk full, temporary permission)?
  - **Recommendation:** Out of scope for bug fix - could be separate enhancement
  - **Decision:** Out of scope

- [ ] Remove duplicate listener at line 234 or keep as backup safety?
  - **Recommendation:** Remove - causes confusion, capture pattern is sufficient
  - **Decision:** Remove (included in plan)

---

## Success Metrics

**Definition of Done:**
- [x] Fix approach minimal (3 lines changed)
- [ ] All 12 existing tests pass (0 regressions)
- [ ] All 5 new tests pass (100% new coverage)
- [ ] All 4 manual verifications pass
- [ ] `/sop-regression-verification` passes (100% gates)
- [ ] PR created with rollback instructions
- [ ] Build succeeds (`npm run build`)

**Monitoring Post-Deploy:**
- Stream error count (expect INCREASE - good, errors now visible)
- Success rate for get_transcript_and_save (expect UNCHANGED ~95%)
- Memory usage (expect UNCHANGED <100MB)
- Test suite pass rate (expect 100%)

---

## References

**Key Files (with line numbers):**
- `src/index.ts:184-199` - BUG LOCATION: Stream error handler with async throw
- `src/index.ts:229-235` - Promise wrapper (needs error check)
- `src/index.ts:254-281` - Outer catch block (verification only)
- `tests/streaming.test.ts:208-221` - Existing weak stream error test (enhance)
- `tests/streaming.test.ts:14-207` - 12 existing tests (must all pass)

**Research References:**
- `.dev/issues/6-*/02-research/research.md` - Full research report with 5 similar patterns
- `.dev/issues/6-*/01-spec/spec-v1-2025-11-05T19:30:00Z.md` - Spec with acceptance criteria

**External Documentation:**
- Node.js Stream API: https://nodejs.org/api/stream.html#event-error
- MCP SDK Error Handling: https://github.com/modelcontextprotocol/typescript-sdk

---

**Plan Version:** v1
**Last Updated:** 2025-11-06T07:00:00Z
**Status:** Ready for Implementation (`/sop-bug-fix`)
