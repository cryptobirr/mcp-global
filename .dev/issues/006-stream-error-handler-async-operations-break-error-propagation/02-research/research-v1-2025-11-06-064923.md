# Research Report: Fix Stream Error Handler Async Operations

**Spec Reference:** `.dev/issues/6-stream-error-handler-async-operations-break-error-propagation/01-spec/spec-v1-2025-11-05T19:30:00Z.md`
**Research Date:** 2025-11-06T06:49:23Z
**Issue:** #6
**Codebase:** mcp-global (youtube-mcp-server)

---

## Executive Summary

**Project Type:** MCP Server (TypeScript/Node.js)
**Complexity:** Simple - isolated bug fix in single error handler
**Brownfield/Greenfield:** Brownfield - modifying existing stream error handling
**Feasibility:** High - standard Node.js error propagation pattern

**Key Findings:**
- Stream error handler at src/index.ts:184-199 uses async callback with throw statement, violating MCP error propagation pattern
- Discovered duplicate error listeners at lines 184 and 234 (overlapping handlers)
- Found 6 correct error propagation patterns in other MCP servers (gmail-mcp, playwright-mcp, mcp-tools)
- Testing infrastructure well-structured but missing 4 critical stream error test cases
- Zero affected features beyond the single tool handler (100% isolation)

---

## Architecture Overview

**Project Type:** Model Context Protocol (MCP) Server
**Language(s):** TypeScript 5.9.3, Node16 ES Modules
**Framework(s):** @modelcontextprotocol/sdk@0.6.0

**Directory Structure:**
- `/servers/binaries/youtube-mcp-server/src/` - Main server implementation (index.ts, 295 lines)
- `/servers/binaries/youtube-mcp-server/tests/` - Unit tests (streaming.test.ts, 222 lines, 12 tests)
- `/servers/binaries/youtube-mcp-server/build/` - Compiled output

**Key Patterns:**
- MCP Protocol: StdioServerTransport for stdio-based communication at index.ts:286-290
- Error Handling: McpError with ErrorCode enum for protocol errors at index.ts:86-97
- Streaming: fs.createWriteStream for memory-efficient transcript writes at index.ts:181
- Testing: Vitest with real file system operations (no mocks) at tests/streaming.test.ts

**Critical Bug Location:**
```typescript
// src/index.ts:184-199 - BROKEN PATTERN
writeStream.on('error', async (err: Error) => {
  // ... cleanup code ...
  throw new McpError(              // ‚ùå LOST - throw in event handler
    ErrorCode.InternalError,
    `Failed to write transcript: ${err.message}`
  );
});
```

**Why It Fails:**
- Event handler callbacks execute outside the request promise chain
- Throws inside event handlers create unhandled promise rejections
- MCP SDK never receives the error, returns success to client despite failure

---

## Similar Patterns Found

### Pattern 1: Direct reject() in Stream Error Handler

**Location:** `tests/streaming.test.ts:122-125`
**Purpose:** Simple Promise-based stream error propagation
**Relevant because:** Shows minimal correct pattern for stream errors

**Code example:**
```typescript
await new Promise<void>((resolve, reject) => {
  writeStream.end(() => resolve());
  writeStream.on('error', reject);  // ‚úÖ CORRECT - error directly rejects
});
```

**Benefits:** Simple, error automatically propagates to catch block
**Limitations:** No cleanup operations, no custom error wrapping

---

### Pattern 2: Capture + Check Error Before Resolve

**Location:** `spec-v1-2025-11-05T19:30:00Z.md:94-124` (proposed fix)
**Purpose:** Stream error handling with cleanup and custom error wrapping
**Relevant because:** Exactly matches requirements for this bug fix

**Code example:**
```typescript
let streamError: Error | null = null;

writeStream.on('error', async (err: Error) => {
  streamError = err;              // ‚úÖ Capture error
  console.error('Stream write error:', err);

  // Cleanup (no throw, just log)
  try {
    await fs.unlink(absoluteOutputPath);
    console.error(`Cleaned up partial file: ${absoluteOutputPath}`);
  } catch (unlinkErr) {
    console.error('Failed to cleanup partial file:', unlinkErr);
  }
});

await new Promise<void>((resolve, reject) => {
  writeStream.end(() => {
    if (streamError) {            // ‚úÖ Check before resolving
      reject(new McpError(
        ErrorCode.InternalError,
        `Failed to write transcript: ${streamError.message}`
      ));
    } else {
      resolve();
    }
  });
  writeStream.on('error', reject); // Backup for post-end errors
});
```

**Test coverage:** Requires new tests for cleanup and rejection path
**Dependencies:** fs/promises unlink, McpError, ErrorCode
**Advantages:** Cleanup before error, custom error wrapping, handles all lifecycle stages

---

### Pattern 3: Process Error Handling with Direct Reject

**Location:** `mcp-tools/src/executor.ts:74-81`
**Purpose:** Child process error propagation
**Relevant because:** Shows correct reject() pattern for event-based errors

**Code example:**
```typescript
childProcess.on('error', (error: any) => {
  this.cleanupProcess(requestId);  // Cleanup first
  if (error.code === 'ENOENT') {
    reject(new MCPNotFoundError(request.server));
  } else {
    reject(error);                 // ‚úÖ Direct reject, not throw
  }
});
```

**Pattern:** Cleanup ‚Üí Check error code ‚Üí Reject with custom error

---

### Pattern 4: HTTP Server with Listener Cleanup

**Location:** `playwright-mcp/src/utils/httpServer.ts:22-31`
**Purpose:** Server startup error handling
**Relevant because:** Shows listener cleanup after success

**Code example:**
```typescript
await new Promise<void>((resolve, reject) => {
  httpServer.on('error', reject);  // Register error handler first

  httpServer.listen(port, host, () => {
    resolve();
    httpServer.removeListener('error', reject);  // ‚úÖ Cleanup after success
  });
});
```

**Key insight:** Remove listeners after one-shot operations to prevent double-rejection

---

### Pattern 5: Pandoc Process with Multiple Error Handlers

**Location:** `gmail-mcp/src/index.ts:578-606`
**Purpose:** External process with stdout/stderr/exit code handling
**Relevant because:** Shows comprehensive error capture patterns

**Code example:**
```typescript
const markdownContent = await new Promise<string>((resolve, reject) => {
  const pandoc = spawn('pandoc', ['-f', 'html', '-t', 'markdown']);
  let output = '';
  let errorOutput = '';

  pandoc.stdout.on('data', (data) => { output += data.toString(); });
  pandoc.stderr.on('data', (data) => { errorOutput += data.toString(); });

  pandoc.on('close', (code) => {
    if (code === 0) {
      resolve(output);
    } else {
      reject(new Error(`Pandoc exited with code ${code}: ${errorOutput}`));
    }
  });

  pandoc.on('error', (err) => {
    reject(new Error(`Failed to start pandoc: ${err.message}`));
  });

  pandoc.stdin.write(htmlContent);
  pandoc.stdin.end();
});
```

**Test coverage:** Spawn errors, exit code errors, stderr capture
**Pattern:** Multiple error sources ‚Üí Single reject path with context

---

## Integration Points

### System: MCP Protocol (@modelcontextprotocol/sdk)

**Current usage:** `src/index.ts:30-52`
**Auth pattern:** No authentication (stdio transport is local)
**Error handling:** McpError with ErrorCode enum at index.ts:86-97, 195-198
**Error propagation:** Synchronous throws in request handler, NOT in callbacks

**Relevant for spec requirement:** Bug fix must ensure McpError reaches MCP SDK via Promise rejection

**Critical constraint:** MCP request handlers return Promise<Result>. Errors must propagate through promise chain, not event handlers.

**Code reference:**
```typescript
// index.ts:82-283 - Tool handler structure
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  try {
    // ... transcript processing ...
  } catch (error) {                    // ‚Üê Must catch Promise rejections
    if (error instanceof Error) {
      return {
        content: [{ type: 'text', text: `Error: ${error.message}` }],
        isError: true
      };
    }
  }
});
```

---

### System: youtube-transcript Library

**Current usage:** `src/index.ts:112-117`
**Integration point:** Fetches transcript entries from YouTube API
**Error patterns:** Throws errors for invalid URLs, disabled/private videos
**Error handling:** Caught by outer try-catch at index.ts:254-281

**Relevant for spec requirement:** Transcript fetch errors already handled correctly (synchronous throws)

**Not affected by bug fix:** YouTube API errors work correctly, only stream write errors are broken

---

### System: Node.js File System (fs/promises, createWriteStream)

**Current usage:**
- `fs.mkdir` at index.ts:176 - Directory creation with recursive:true
- `createWriteStream` at index.ts:181 - Stream-based file writes
- `fs.unlink` at index.ts:189 - Cleanup partial files on error

**Error patterns:**
- mkdir: ENOENT (parent missing), EACCES (permission denied)
- createWriteStream: ENOSPC (disk full), EROFS (read-only), EACCES
- unlink: ENOENT (file missing), EACCES (permission denied)

**Relevant for spec requirement:**
- Bug affects writeStream error handling (createWriteStream errors)
- Cleanup (fs.unlink) must complete before error propagation
- Cleanup failures should log but not block main error

---

## Testing Infrastructure

**Framework:** Vitest 4.0.7 with Node environment
**Test Location:** `/tests/streaming.test.ts`
**Conventions:** Describe blocks per feature, beforeEach/afterEach for cleanup

**Test Types Present:**
- Unit: Chunk processing tests at tests/streaming.test.ts:14-76
- Unit: HTML entity decoding at tests/streaming.test.ts:78-96
- Integration: Memory usage with real streams at tests/streaming.test.ts:98-132
- Integration: Progress logging at tests/streaming.test.ts:134-171
- Unit: Filename sanitization at tests/streaming.test.ts:173-206
- Integration: Stream error handling at tests/streaming.test.ts:208-221 (WEAK)

**Test Infrastructure:**
- Database: N/A
- API mocks: NO MOCKS - Real file system operations
- Fixtures: Synthetic data via Array.from(), no external fixtures
- Cleanup: beforeEach/afterEach with fs.mkdir/fs.rm at tests/streaming.test.ts:9-17

**CI/CD Gates:**
- All tests must pass (`npm test`)
- No explicit coverage minimum in package.json
- Build step (`npm run build`) compiles TypeScript

**Critical Gap:** Existing stream error test (lines 208-221) only validates error event emission, NOT:
- Error propagation to Promise rejection
- Cleanup execution (fs.unlink)
- McpError wrapping
- Outer catch block receives error

---

## Risks & Constraints

### Known Issues

**BUG at src/index.ts:184-199:** Stream error handler uses async callback with throw, error is lost
**CODE SMELL at src/index.ts:234:** Duplicate error listener overlaps with line 184 handler

**Mitigation:** Remove duplicate listener at line 234, use single unified error capture pattern

---

### Performance Constraints

**Memory limit:** <100MB peak for streaming transcripts (per tests/streaming.test.ts:98-132)
**Chunk size:** Fixed at 1000 entries per src/index.ts:205
**Progress threshold:** 5000 entries before logging per src/index.ts:222

**Implication for bug fix:** Cleanup operations (fs.unlink) add 10-50ms latency before error propagation, acceptable given error scenarios are rare

---

### Breaking Change Risks

**1. Error Propagation Changes (CRITICAL)**
- **Current behavior:** Stream errors silently succeed, clients receive success response
- **New behavior:** Stream errors properly reject, clients receive error response
- **Affected clients:** ALL MCP clients using get_transcript_and_save tool
- **Mitigation:** Intentional bug fix, clients SHOULD handle errors

**2. Duplicate Error Listeners Removed (LOW)**
- **Current behavior:** Two overlapping error handlers (lines 184, 234)
- **New behavior:** Single unified error handler
- **Risk:** Minimal, second handler was redundant backup

**3. Cleanup Timing (LOW)**
- **Current behavior:** Cleanup attempted but error lost, partial files may remain
- **New behavior:** Cleanup completes before error propagated
- **Risk:** Adds 10-50ms latency in error cases only

---

### Migration Needs

**Schema changes:** None - no database, no data model changes
**File structure:** None - existing files only
**Config changes:** None - no new environment variables

**Code refactoring required:**
1. Lines 184-199: Replace throw with error capture variable
2. Lines 229-235: Add streamError check before resolve()
3. Line 234: Remove duplicate error listener
4. tests/streaming.test.ts: Add 4 new test cases for error propagation

---

## Impact Analysis & Regression Risks

**Purpose:** Identify ALL existing features that could regress when fixing stream error propagation

### Affected Features (Regression Test Candidates)

**Feature 1: get_transcript_and_save Tool (ONLY FEATURE)**
- **Why Affected:** Modifying error handling in this tool's writeStream operations
- **Integration Points:** src/index.ts:82-283 entire tool handler
- **Regression Risk:** Error responses where clients previously saw success (BREAKING)
- **Regression Tests Needed:**
  - Unit: Verify stream error triggers Promise rejection with McpError
  - Unit: Verify cleanup (fs.unlink) executes before rejection
  - Unit: Verify cleanup failures don't block main error propagation
  - Integration: Verify error reaches outer catch block (lines 254-281)
  - Integration: Verify MCP client receives error content, not success
  - Manual: Test with real invalid path, disk full scenario

**NO OTHER FEATURES:** This is the only tool in the server (confirmed via src/index.ts:56-79)

---

### Regression Test Coverage Matrix

| Feature | Unit Tests Needed | Integration Tests Needed | Manual Verification Needed |
|---------|-------------------|--------------------------|----------------------------|
| get_transcript_and_save error path | 3 tests (Promise rejection, cleanup, cleanup failure) | 2 tests (outer catch, MCP response) | 2 scenarios (invalid path, disk full) |
| get_transcript_and_save success path | 0 (existing tests sufficient) | 0 (existing tests sufficient) | 1 scenario (verify no regression) |

**Total Regression Tests Required:** 5 automated + 3 manual = 8 tests
**Features Requiring Verification:** 1 feature (100% of server functionality)
**Coverage Target:** 100% (error path and success path verified)

---

### Blast Radius Summary

**Direct Impact:** 1 file modified (src/index.ts) ‚Üí 1 feature affected (get_transcript_and_save)
**Indirect Impact:** 0 features use this tool's error handling behavior
**Total Affected Features:** 1 (100% isolation - no cascading effects)

**Verification Strategy:**
- ALL error handling code paths MUST have regression tests
- Execute existing 12 tests to verify no success path regression
- Add 5 new tests for error path coverage
- Manual testing with real error scenarios (invalid paths, disk full)
- Zero tolerance for test failures

**Risk Level:** MEDIUM-HIGH
- Implementation risk: LOW (standard Node.js pattern)
- Breaking change risk: HIGH (clients must handle new error responses)
- Localization: HIGH (single tool, no dependencies)

---

## Blocking Decisions

### üö® Decision Required: Error Handler Pattern Choice

**Context:** Spec requires fixing stream error propagation. Two viable patterns exist with different tradeoffs.

**Options:**

#### Option A: Capture Error + Check Before Resolve (RECOMMENDED IN SPEC)

**Description:** Store error in outer scope variable, check in end() callback before resolving

**Code pattern:**
```typescript
let streamError: Error | null = null;

writeStream.on('error', async (err: Error) => {
  streamError = err;
  // ... cleanup ...
});

await new Promise<void>((resolve, reject) => {
  writeStream.end(() => {
    if (streamError) {
      reject(new McpError(...));
    } else {
      resolve();
    }
  });
  writeStream.on('error', reject);  // Backup for post-end errors
});
```

**Pros:**
- Allows cleanup (fs.unlink) before error propagation
- Custom error wrapping with McpError
- Detailed logging before rejection
- Handles errors at all lifecycle stages (pre-end, during-end, post-end)

**Cons:**
- More complex than direct reject (requires variable tracking)
- Two error listeners (pre-end capture, post-end reject)
- Potential race condition if error fires during end() callback

**Complexity:** Medium
**Implementation Impact:**
- src/index.ts:184-199 - Replace throw with capture pattern
- src/index.ts:229-235 - Add streamError check
- tests/streaming.test.ts - Add 4 new test cases

---

#### Option B: Direct Reject Only (SIMPLER)

**Description:** Remove cleanup from error handler, use direct reject() pattern

**Code pattern:**
```typescript
await new Promise<void>((resolve, reject) => {
  writeStream.on('error', (err: Error) => {
    reject(new McpError(
      ErrorCode.InternalError,
      `Failed to write transcript: ${err.message}`
    ));
  });

  writeStream.end(() => {
    console.error(`Transcript saved to: ${absoluteOutputPath}`);
    resolve();
  });
});
```

**Pros:**
- Simpler implementation (no variable tracking)
- Single error listener, no race conditions
- Follows standard Promise error pattern

**Cons:**
- No cleanup (partial files remain on error)
- Error handler cannot be async (no await)
- Less detailed error logging

**Complexity:** Low
**Implementation Impact:**
- src/index.ts:184-199 - Remove handler, add reject() in Promise
- src/index.ts:229-235 - Update Promise to include error listener
- tests/streaming.test.ts - Add 2 new test cases (simpler tests)

---

**Recommendation:** Option A (Capture + Check Before Resolve)

**Rationale:**
- Spec explicitly requires cleanup before error propagation (AC2)
- Partial files should not litter file system on errors
- Detailed logging critical for debugging MCP server issues
- Complexity acceptable for 50 lines of code with clear tests
- Aligns with existing pattern: cleanup try-catch already exists in current code
- Future-proof: handles all error lifecycle stages

**Spec alignment:** AC2 states "Cleanup happens before error propagation" - requires Option A

---

## Recommendations for Planning Phase

**Approach:** Brownfield modification - targeted bug fix in single error handler

**Files to Modify:**
- `src/index.ts:184-199` - Replace async throw with error capture pattern
- `src/index.ts:229-235` - Add streamError check before Promise resolve
- `src/index.ts:234` - Remove duplicate error listener (line deletion)
- `tests/streaming.test.ts:208-221` - Enhance existing stream error test
- `tests/streaming.test.ts` - Add 4 new test cases for error propagation

**New Files Needed:**
- None - all changes in existing files

**Test Strategy:**
- Unit tests: Promise rejection, cleanup execution, cleanup failure handling, error capture
- Integration tests: Outer catch receives McpError, MCP client gets error response
- NO MOCKS - Use real file system errors (invalid paths, read-only dirs)
- Verify existing 12 tests still pass (no success path regression)

**Dependencies:**
- Existing: fs/promises (unlink), createWriteStream, McpError, ErrorCode
- New: None

**Open Questions for Planning:**
- [ ] Should cleanup failures (fs.unlink errors) include details in McpError message or just log?
- [ ] Should we add retry logic for transient errors (disk full, temporary permission)?
- [ ] Remove duplicate listener at line 234 or keep as backup safety?

---

## References

**Key Files (with line numbers):**
- src/index.ts:30-52 - MCP server initialization and stdio transport
- src/index.ts:54-284 - Tool handler setup with get_transcript_and_save implementation
- src/index.ts:86-97 - Correct McpError throwing patterns (synchronous)
- src/index.ts:184-199 - BUG LOCATION: Stream error handler with async throw
- src/index.ts:229-235 - Promise wrapper for stream closure (needs streamError check)
- src/index.ts:254-281 - Outer catch block that should receive error (verification only)
- tests/streaming.test.ts:9-17 - Test setup/teardown with real file system
- tests/streaming.test.ts:122-125 - Correct direct reject() pattern for streams
- tests/streaming.test.ts:208-221 - Weak stream error test (needs enhancement)

**Similar Patterns in Other Servers:**
- mcp-tools/src/executor.ts:74-81 - Process error handling with direct reject
- playwright-mcp/src/utils/httpServer.ts:22-31 - HTTP server with listener cleanup
- gmail-mcp/src/index.ts:578-606 - Pandoc process with comprehensive error handlers
- postgres-mcp-server/src/common/pg_agent.ts:46-48 - Ambient error logging pattern

**External Documentation:**
- Node.js Stream API: https://nodejs.org/api/stream.html#event-error
- MCP SDK: https://github.com/modelcontextprotocol/typescript-sdk
