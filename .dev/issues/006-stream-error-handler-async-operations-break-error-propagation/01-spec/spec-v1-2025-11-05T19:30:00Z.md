## ðŸ“‹ SPEC: Fix Stream Error Handler Async Operations

**Approach:** BROWNFIELD
**Tech Stack:** TypeScript, Node.js Streams, fs/promises
**Feature Type:** BACKEND

---

### What We're Building

Fix the broken error propagation in YouTube MCP server's stream error handler where thrown errors from async callbacks are lost, causing silent failures during transcript processing.

---

### User Flow

1. MCP client requests transcript download for large YouTube video
2. Server creates writeStream and begins writing chunks to file
3. **ERROR OCCURS** during write operation (disk full, permission denied, invalid path)
4. Stream 'error' event fires, handler attempts cleanup and throws McpError
5. **BUG:** Thrown error is lost because it's inside event callback - Promise wrapper never rejects
6. Server continues execution, calls `writeStream.end()`, Promise resolves successfully
7. **RESULT:** Client receives success response despite file being corrupt/incomplete
8. **EXPECTED:** Error should propagate to Promise wrapper â†’ reject promise â†’ caught by outer catch â†’ McpError returned to client

---

### Requirements

**Must Have:**
- Stream errors during write operations MUST propagate to the Promise wrapper and reject it
- Cleanup operations (fs.unlink for partial files) MUST complete before error propagation
- Error propagation MUST work for errors at ANY point in the stream lifecycle (pre-end, during-end, post-end)
- The McpError thrown MUST reach the outer catch block at index.ts:254-281
- Error handling MUST use a single unified pattern, not overlapping handlers

**Should Have:**
- Error handler should log detailed diagnostics for debugging
- Cleanup failures should be logged but not block error propagation
- Error messages should include original error context

**Must NOT:**
- âŒ Throw errors inside event handler callbacks (they are lost)
- âŒ Use multiple overlapping error listeners that can conflict
- âŒ Allow silent failures where stream errors don't reach the caller
- âŒ Skip cleanup operations when errors occur
- âŒ Block error propagation while waiting for cleanup

---

### Acceptance Criteria

**AC1:** Stream write errors propagate correctly to caller
- Given: Stream write operation fails (disk full, invalid path, permission denied)
- When: Error event fires on writeStream
- Then: Error is captured, cleanup completes, Promise wrapper rejects with McpError, outer catch receives error

**AC2:** Cleanup happens before error propagation
- Given: Stream error occurs and partial file exists
- When: Error handler executes
- Then: fs.unlink removes partial file BEFORE Promise rejects, cleanup logs appear before error propagation

**AC3:** Errors at any lifecycle stage are caught
- Given: Error occurs during pre-end writes, during end(), or post-end flush
- When: Error event fires at any stage
- Then: Error is propagated to Promise wrapper and rejected consistently

**AC4:** No overlapping error handlers
- Given: Stream is created with error handling
- When: Code registers error listeners
- Then: Only ONE error handler pattern exists (unified), no conflicts between pre-end and post-end handlers

---

### Implementation Notes

**[For BROWNFIELD Projects]:**
- Files to modify: `servers/binaries/youtube-mcp-server/src/index.ts:184-235`
- Pattern to follow: Use Promise wrapper with reject callback, capture errors in outer scope variable instead of throwing
- Integration points:
  - Lines 184-199: Remove throw from error handler, capture error in variable
  - Lines 229-235: Check captured error variable before resolving Promise
  - Lines 254-281: Outer catch already exists, no changes needed
- Testing approach: Update `servers/binaries/youtube-mcp-server/tests/streaming.test.ts`, add test case that simulates write error and verifies Promise rejection
- Migration strategy: Refactor error handler to use reject callback pattern:

```typescript
// CURRENT (BROKEN):
writeStream.on('error', async (err: Error) => {
  // ... cleanup ...
  throw new McpError(...);  // LOST
});

// PROPOSED FIX:
let streamError: Error | null = null;

writeStream.on('error', async (err: Error) => {
  streamError = err;
  console.error('Stream write error:', err);

  // Cleanup partial file
  try {
    await fs.unlink(absoluteOutputPath);
    console.error(`Cleaned up partial file: ${absoluteOutputPath}`);
  } catch (unlinkErr) {
    console.error('Failed to cleanup partial file:', unlinkErr);
  }
});

// Promise wrapper checks captured error
await new Promise<void>((resolve, reject) => {
  writeStream.end(() => {
    if (streamError) {
      reject(new McpError(
        ErrorCode.InternalError,
        `Failed to write transcript: ${streamError.message}`
      ));
    } else {
      console.error(`Transcript saved to: ${absoluteOutputPath}`);
      resolve();
    }
  });
  // Remove duplicate error listener at line 234
});
```

**Testing Requirements:**
- Real stream errors (use invalid paths, read-only directories)
- NO MOCKS for fs operations
- Verify Promise rejection with McpError
- Verify cleanup (fs.unlink) completes before rejection
- Verify error reaches outer catch block
- Test all lifecycle stages: pre-end, during-end, post-end errors

---

### Open Questions

- [ ] Should we add retry logic for transient errors (disk full, temporary permission issues)?
- [ ] Should cleanup failures (fs.unlink errors) be included in the McpError or just logged?

### Out of Scope

- Duplicate error listeners issue (mentioned in issue description as separate issue)
- Performance optimization for large file writes
- Alternative streaming libraries or patterns
- Error handling for OTHER stream types (readStream, etc.) - only fixing writeStream
